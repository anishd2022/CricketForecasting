---
title: "Mactivate"
author: "Anish Deshpande"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# import necessary libraries
library(tidyverse)
library(reticulate)
library(ggplot2)
library(mactivate)
```



```{r}
# import and load tensor data
np <- import("numpy")
data <- np$load("t20_tensor_data.npz", allow_pickle=TRUE)

tensor <- data$f[["tensor"]]
units <- data$f[["units"]]
metrics <- data$f[["metrics"]]
```


## Build the dataset for regression:
```{r}
N <- dim(tensor)[1]

valid_units <- logical(N)
for (i in 1:N) {
  inning_slice <- tensor[i, , ]
  valid_units[i] <- !any(is.na(inning_slice))
}

tensor_clean <- tensor[valid_units, , ]
```


```{r}
cumulative_runs <- c()
cumulative_wickets <- c()
final_scores <- c()

intervention_ball <- 60
N <- dim(tensor_clean)[1]

for (i in 1:N) {
  run_vec <- tensor_clean[i, , 1]
  wicket_vec <- tensor_clean[i, , 2]

  if (any(is.na(run_vec)) || any(is.na(wicket_vec))) next
  if (sd(run_vec, na.rm = TRUE) == 0) next

  cum_runs <- run_vec[intervention_ball + 1]
  cum_wkts <- wicket_vec[intervention_ball + 1]
  final <- run_vec[120]

  if (is.na(cum_runs) || is.na(cum_wkts) || is.na(final)) next

  cumulative_runs <- c(cumulative_runs, cum_runs)
  cumulative_wickets <- c(cumulative_wickets, cum_wkts)
  final_scores <- c(final_scores, final)
}

df <- data.frame(
  cumulative_runs = cumulative_runs,
  cumulative_wickets = cumulative_wickets,
  final_score = final_scores
)

head(df)
```


```{r}
X <- scale(df[, c("cumulative_runs", "cumulative_wickets")])
y <- df$final_score

stopifnot(!any(is.na(X)), !any(is.infinite(X)))
```


## Set control params for fitting:
```{r}
xcmact <- f_control_mactivate(
  param_sensitivity = 1e5,
  bool_free_w = TRUE,
  w0_seed = 0.05,
  w_col_search = "alternate",
  bool_headStart = TRUE,
  ss_stop = 1e-8,
  escape_rate = 1.01,
  Wadj = 1,
  lambda = 0.001,
  tol = 1e-8
)
```



## Fit the model with multiple activation:
```{r}
m_tot <- 5  # number of m-activation columns
U <- X      # U = inputs to activation layer (same as X here)

fit <- f_fit_gradient_01(
  X = X,
  y = y,
  m_tot = m_tot,
  U = U,
  m_start = 1,
  mact_control = xcmact,
  verbosity = 1
)
```


## Predict final score
```{r}
yhat_mat <- matrix(NA, nrow(X), m_tot + 1)

for (mcols in 0:m_tot) {
  yhat <- predict(object = fit, X0 = X, U0 = U, mcols = mcols)
  yhat_mat[, mcols + 1] <- yhat
}

# Use best model (usually the one with highest mcols)
yhat_best <- yhat_mat[, m_tot + 1]
```


## evaluate performance:
```{r}
r_squared <- 1 - sum((y - yhat_best)^2) / sum((y - mean(y))^2)
mae <- mean(abs(y - yhat_best))

cat(sprintf("R-squared: %.4f\nMAE: %.2f runs\n", r_squared, mae))
```


## Plto predicted vs actual:
```{r}
df_plot <- data.frame(
  actual = y,
  predicted = yhat_best
)

ggplot(df_plot, aes(x = actual, y = predicted)) +
  geom_point(alpha = 0.4, color = "#1f77b4", size = 2) +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed", size = 1) +
  labs(
    title = "Actual vs Predicted Final Scores (mactivate)",
    x = "Actual Final Score",
    y = "Predicted Final Score"
  ) +
  theme_minimal(base_size = 14) +
  coord_equal()
```












